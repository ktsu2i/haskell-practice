{-
Quizzes generated by ChatGPT 5.2-thinking
-}
import Text.Read (readMaybe)
import Data.Maybe (mapMaybe)

-- add3: adds three integers
add3 :: Int -> Int -> Int -> Int
add3 x y z = x + y + z

-- swap: swaps two elements in a tuple
swap :: (a, b) -> (b, a)
swap (x, y) = (y, x)

-- isZero: checks if it's zero or not
isZero :: Int -> Bool
isZero num = num == 0

{-
isZero with pattern matching:
isZero 0 = True
isZero _ = False
-}

-- safeTail: drops the first element in a list
safeTail :: [a] -> Maybe [a]
safeTail [] = Nothing
safeTail (_:xs) = Just xs

-- between: checks if the target is between low and high integers
between :: Int -> Int -> Int -> Bool
between low high n
  | n < low = False
  | n > high = False
  | otherwise = True

-- or, low <= n && n <= high

-- grade: converts a score (integer) to string
-- A ~90, B ~80, C ~70, F 69~
grade :: Int -> String
grade n
  | n >= 90 = "A"
  | n >= 80 = "B"
  | n >= 70 = "C"
  | otherwise = "F"

-- doubleAll: multiplies all the integers by 2
doubleAll :: [Int] -> [Int]
doubleAll = map (* 2)

-- onlyEven: drops all the odds
onlyEven :: [Int] -> [Int]
onlyEven = filter even

-- sumSquaresOfEvens: returns sum of only even integers
sumSquaresOfEvens :: [Int] -> Int
sumSquaresOfEvens xs = sum $ map (\x -> x * x) (filter even xs)
-- sumSquaresOfEvens = sum . map (\x -> x * x) . filter even 

-- count: counts a number of elements in a list with the given condition
count :: (a -> Bool) -> [a] -> Int
count p xs = length (filter p xs)
-- count p xs = foldl (\acc x -> if p x then acc + 1 else acc) 0 xs

-- safeLast: returns the last element safely
safeLast :: [a] -> Maybe a
safeLast [] = Nothing
safeLast [x] = Just x
safeLast (_:xs) = safeLast xs

-- maybeToList: converts maybe to a list
maybeToList :: Maybe a -> [a]
maybeToList Nothing = []
maybeToList (Just x) = [x]

-- listToMaybe: returns the first element in a list unsafely
listToMaybe :: [a] -> Maybe a
listToMaybe [] = Nothing
listToMaybe (x:_) = Just x

-- safeReadInt: takes string and returns an integer if included
safeReadInt :: String -> Maybe Int
safeReadInt s = readMaybe s :: Maybe Int
-- safeReadInt s = readMaybe s
-- safeReadInt = readMaybe

-- parseLine: converts to a tuple like (name, score)
parseLine :: String -> Maybe (String, Int)
parseLine s =
  case break (== ',') s of
    (name, ',' : rest) ->
      case safeReadInt rest of
        Just n -> Just (name, n)
        Nothing -> Nothing
    _ -> Nothing

parseLine2 s = do
  let (name, after) = break (== ',') s
  case after of
    ',' : rest -> do
      n <- safeReadInt rest
      Just (name, n)
    _ -> Nothing

-- parseScore: reads after commas and returns an integer as a score
parseScore :: String -> Maybe Int
parseScore s =
  case break (== ',') s of
    (_, ',' : rest) -> safeReadInt rest
    _ -> Nothing

-- sumScores: returns the sum of scores
sumScores :: [String] -> Int
sumScores xs = sum (mapMaybe parseScore xs)
-- sumScores = sum . mapMaybe parseScore
